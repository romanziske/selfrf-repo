"""
Utility to convert a **COCO-style** dataset into the directory/label
layout expected by `Ultralytics YOLO <https://docs.ultralytics.com/datasets/format/>`_.

**Input Structure (New Format):**

.. code-block:: text

    <COCO_ROOT>
    ├── train/
    │   ├── _annotations.coco.json
    │   ├── 000000000001.png
    │   └── 000000000002.png
    ├── valid/
    │   ├── _annotations.coco.json
    │   ├── 000000000003.png
    │   └── 000000000004.png
    └── test/
        ├── _annotations.coco.json
        ├── 000000000005.png
        └── 000000000006.png

**Output Structure:**

.. code-block:: text

    <OUT_DIR>
    ├── images/train … (copied or symlinked)
    ├── images/val
    ├── images/test
    ├── labels/train … (YOLO .txt)
    ├── labels/val
    ├── labels/test
    └── data.yaml      (dataset config)

Modes
-----

.. list-table::
   :header-rows: 1
   :widths: 20 80

   * - ``--mode``
     - Behaviour
   * - **detection**
     - Single-class object detection. All annotations are mapped to class ``0``, and ``data.yaml`` contains ``names: ['signal']``.
   * - **recognition**
     - Object *recognition*: keeps the original COCO categories (default Ultralytics behaviour).

CLI Usage
---------

.. code-block:: bash

    # 1 Pure signal-/object-detection (single class, save space with symlinks)
    python convert_coco_to_yolo.py \
           --coco_dir ./coco --out_dir ./yolo_det \
           --mode detection --symlink

    # 2 Full recognition (multi-class)
    python convert_coco_to_yolo.py \
           --coco_dir ./coco --out_dir ./yolo_rec \
           --mode recognition --splits train valid test
"""
from __future__ import annotations

import json
import shutil
from pathlib import Path
from typing import Dict, List


def coco_to_yolo_bbox(bbox: List[float], img_w: int, img_h: int) -> List[float]:
    """
    Converts absolute COCO bounding box format to normalized YOLO format.

    :param bbox: COCO bounding box as [x, y, width, height]
    :type bbox: List[float]
    :param img_w: Image width in pixels
    :type img_w: int
    :param img_h: Image height in pixels
    :type img_h: int
    :returns: YOLO normalized bounding box as [x_center, y_center, width, height]
    :rtype: List[float]
    """
    x, y, w, h = bbox
    xc = (x + w / 2) / img_w
    yc = (y + h / 2) / img_h
    return [xc, yc, w / img_w, h / img_h]


def makedirs(p: Path):
    """
    Creates directory and all parent directories if they don't exist.

    :param p: Path to directory to create
    :type p: Path
    """
    p.mkdir(parents=True, exist_ok=True)


def write_data_yaml(path: Path, names: List[str], splits: List[str]):
    """
    Writes Ultralytics data.yaml configuration file with class names and paths.

    :param path: Path where data.yaml file will be written
    :type path: Path
    :param names: List of class names for the dataset
    :type names: List[str]
    :param splits: List of dataset splits to include in config
    :type splits: List[str]
    """
    root = path.parent.resolve()
    content = f"# Auto-generated by convert_coco_to_yolo.py\n"
    content += f"path: {root}\n"

    # Add available splits
    for split in splits:
        if split == "valid":
            content += f"val: images/val\n"  # YOLO uses 'val' not 'valid'
        else:
            content += f"{split}: images/{split}\n"

    content += f"nc: {len(names)}\n"
    content += f"names: {names}\n"

    path.write_text(content)


def convert_split(
    *,
    coco_json: Path,
    split: str,
    out_images: Path,
    out_labels: Path,
    id2index: Dict[int, int],
    symlink: bool,
):
    """
    Converts one dataset split from COCO to YOLO format with images and labels.

    :param coco_json: Path to COCO annotation JSON file (_annotations.coco.json)
    :type coco_json: Path
    :param split: Dataset split name (train/valid/test)
    :type split: str
    :param out_images: Output directory for images
    :type out_images: Path
    :param out_labels: Output directory for YOLO label files
    :type out_labels: Path
    :param id2index: Mapping from COCO category IDs to YOLO class indices
    :type id2index: Dict[int, int]
    :param symlink: Whether to symlink images instead of copying
    :type symlink: bool
    :raises FileNotFoundError: If source images or annotation file not found
    :raises json.JSONDecodeError: If COCO JSON file is malformed
    """

    print(f"\n[+] Processing {split} split: {coco_json}")

    with coco_json.open() as f:
        coco = json.load(f)

    # index image metadata by id
    img_meta = {img["id"]: img for img in coco["images"]}

    makedirs(out_images)
    makedirs(out_labels)

    # group annos per image
    ann_per_img: Dict[int, List[dict]] = {}
    for ann in coco["annotations"]:
        ann_per_img.setdefault(ann["image_id"], []).append(ann)

    # Get source image directory (same directory as annotations)
    src_img_dir = coco_json.parent

    # iterate images
    for img_id, meta in img_meta.items():
        fname = Path(meta["file_name"]).name  # ensure just the leaf filename
        src_img = src_img_dir / fname
        dst_img = out_images / fname

        if not src_img.exists():
            print(f"Warning: Source image not found: {src_img}")
            continue

        if symlink:
            if dst_img.exists() or dst_img.is_symlink():
                dst_img.unlink()
            dst_img.symlink_to(src_img.resolve())
        else:
            shutil.copy2(src_img, dst_img)

        # build label file
        label_lines: List[str] = []
        for ann in ann_per_img.get(img_id, []):
            if ann.get("iscrowd", 0):
                continue  # skip crowd boxes
            cls = id2index[ann["category_id"]]
            x, y, w, h = coco_to_yolo_bbox(
                ann["bbox"], meta["width"], meta["height"])
            label_lines.append(f"{cls} {x:.6f} {y:.6f} {w:.6f} {h:.6f}")

        (out_labels /
         f"{Path(fname).stem}.txt").write_text("\n".join(label_lines))

    action = "Symlinked" if symlink else "Copied"
    print(
        f"    → {action} {len(img_meta)} images and wrote labels to '{out_labels}'.")


def convert_coco_to_yolo(
    coco_dir: Path,
    out_dir: Path,
    splits: List[str] = None,
    symlink: bool = False,
    mode: str = "recognition"
) -> Path:
    """
    Converts complete COCO dataset to Ultralytics YOLO format with configurable class handling.

    :param coco_dir: Root directory of COCO dataset containing split subdirectories
    :type coco_dir: Path
    :param out_dir: Output directory for converted YOLO dataset
    :type out_dir: Path
    :param splits: Dataset splits to convert, defaults to ["train", "valid"]
    :type splits: List[str]
    :param symlink: Whether to symlink images instead of copying them
    :type symlink: bool
    :param mode: Conversion mode - "detection" for single class or "recognition" for multi-class
    :type mode: str
    :returns: Path to the generated data.yaml configuration file
    :rtype: Path
    :raises FileNotFoundError: If required annotation files or directories are missing
    :raises ValueError: If mode is not "detection" or "recognition"
    :raises json.JSONDecodeError: If COCO annotation files are malformed
    """
    if splits is None:
        splits = ["train", "valid"]

    if mode not in ["detection", "recognition"]:
        raise ValueError(
            f"Mode must be 'detection' or 'recognition', got '{mode}'")

    coco_dir = coco_dir.expanduser().resolve()
    out_dir = out_dir.expanduser().resolve()

    # Check if train split exists and get categories from it
    train_split_dir = coco_dir / "train"
    if not train_split_dir.is_dir():
        raise FileNotFoundError(
            f"{train_split_dir} missing - expected COCO 'train' directory.")

    train_json = train_split_dir / "_annotations.coco.json"
    if not train_json.is_file():
        raise FileNotFoundError(
            f"Required annotation file not found: {train_json}")

    with train_json.open() as f:
        cats = json.load(f)["categories"]

    if mode == "detection":
        # collapse to a single class "signal"
        names = ["signal"]
        id2index = {c["id"]: 0 for c in cats}
    else:  # recognition
        cats_sorted = sorted(cats, key=lambda c: c["id"])
        names = [c["name"] for c in cats_sorted]
        id2index = {c["id"]: i for i, c in enumerate(cats_sorted)}

    # prepare output root
    makedirs(out_dir / "images")
    makedirs(out_dir / "labels")

    # Process each split
    processed_splits = []
    for split in splits:
        split_dir = coco_dir / split
        json_path = split_dir / "_annotations.coco.json"

        if not split_dir.is_dir():
            print(
                f"Warning: Split directory not found: {split_dir}, skipping.")
            continue

        if not json_path.is_file():
            print(
                f"Warning: Annotation file not found: {json_path}, skipping.")
            continue

        # Use 'val' for YOLO instead of 'valid'
        yolo_split = "val" if split == "valid" else split

        convert_split(
            coco_json=json_path,
            split=split,
            out_images=out_dir / "images" / yolo_split,
            out_labels=out_dir / "labels" / yolo_split,
            id2index=id2index,
            symlink=symlink,
        )
        processed_splits.append(yolo_split)

    if not processed_splits:
        raise ValueError("No valid splits were processed!")

    data_yaml_path = out_dir / "data.yaml"
    write_data_yaml(data_yaml_path, names, processed_splits)
    print(
        f"\nConversion finished ({mode} mode). Dataset ready at: {out_dir}\n")
    print(f"Processed splits: {processed_splits}")

    return data_yaml_path
